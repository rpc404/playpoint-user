{"version":3,"file":"index5.js","sources":["../node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js","../node_modules/@ethersproject/units/lib.esm/_version.js","../node_modules/@ethersproject/units/lib.esm/index.js"],"sourcesContent":["\"use strict\";\nimport { arrayify, hexZeroPad, isBytes } from \"@ethersproject/bytes\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { BigNumber, isBigNumberish } from \"./bignumber\";\nconst _constructorGuard = {};\nconst Zero = BigNumber.from(0);\nconst NegativeOne = BigNumber.from(-1);\nfunction throwFault(message, fault, operation, value) {\n    const params = { fault: fault, operation: operation };\n    if (value !== undefined) {\n        params.value = value;\n    }\n    return logger.throwError(message, Logger.errors.NUMERIC_FAULT, params);\n}\n// Constant to pull zeros from for multipliers\nlet zeros = \"0\";\nwhile (zeros.length < 256) {\n    zeros += zeros;\n}\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getMultiplier(decimals) {\n    if (typeof (decimals) !== \"number\") {\n        try {\n            decimals = BigNumber.from(decimals).toNumber();\n        }\n        catch (e) { }\n    }\n    if (typeof (decimals) === \"number\" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {\n        return (\"1\" + zeros.substring(0, decimals));\n    }\n    return logger.throwArgumentError(\"invalid decimal size\", \"decimals\", decimals);\n}\nexport function formatFixed(value, decimals) {\n    if (decimals == null) {\n        decimals = 0;\n    }\n    const multiplier = getMultiplier(decimals);\n    // Make sure wei is a big number (convert as necessary)\n    value = BigNumber.from(value);\n    const negative = value.lt(Zero);\n    if (negative) {\n        value = value.mul(NegativeOne);\n    }\n    let fraction = value.mod(multiplier).toString();\n    while (fraction.length < multiplier.length - 1) {\n        fraction = \"0\" + fraction;\n    }\n    // Strip training 0\n    fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];\n    const whole = value.div(multiplier).toString();\n    if (multiplier.length === 1) {\n        value = whole;\n    }\n    else {\n        value = whole + \".\" + fraction;\n    }\n    if (negative) {\n        value = \"-\" + value;\n    }\n    return value;\n}\nexport function parseFixed(value, decimals) {\n    if (decimals == null) {\n        decimals = 0;\n    }\n    const multiplier = getMultiplier(decimals);\n    if (typeof (value) !== \"string\" || !value.match(/^-?[0-9.]+$/)) {\n        logger.throwArgumentError(\"invalid decimal value\", \"value\", value);\n    }\n    // Is it negative?\n    const negative = (value.substring(0, 1) === \"-\");\n    if (negative) {\n        value = value.substring(1);\n    }\n    if (value === \".\") {\n        logger.throwArgumentError(\"missing value\", \"value\", value);\n    }\n    // Split it into a whole and fractional part\n    const comps = value.split(\".\");\n    if (comps.length > 2) {\n        logger.throwArgumentError(\"too many decimal points\", \"value\", value);\n    }\n    let whole = comps[0], fraction = comps[1];\n    if (!whole) {\n        whole = \"0\";\n    }\n    if (!fraction) {\n        fraction = \"0\";\n    }\n    // Trim trailing zeros\n    while (fraction[fraction.length - 1] === \"0\") {\n        fraction = fraction.substring(0, fraction.length - 1);\n    }\n    // Check the fraction doesn't exceed our decimals size\n    if (fraction.length > multiplier.length - 1) {\n        throwFault(\"fractional component exceeds decimals\", \"underflow\", \"parseFixed\");\n    }\n    // If decimals is 0, we have an empty string for fraction\n    if (fraction === \"\") {\n        fraction = \"0\";\n    }\n    // Fully pad the string with zeros to get to wei\n    while (fraction.length < multiplier.length - 1) {\n        fraction += \"0\";\n    }\n    const wholeValue = BigNumber.from(whole);\n    const fractionValue = BigNumber.from(fraction);\n    let wei = (wholeValue.mul(multiplier)).add(fractionValue);\n    if (negative) {\n        wei = wei.mul(NegativeOne);\n    }\n    return wei;\n}\nexport class FixedFormat {\n    constructor(constructorGuard, signed, width, decimals) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot use FixedFormat constructor; use FixedFormat.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new FixedFormat\"\n            });\n        }\n        this.signed = signed;\n        this.width = width;\n        this.decimals = decimals;\n        this.name = (signed ? \"\" : \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n        this._multiplier = getMultiplier(decimals);\n        Object.freeze(this);\n    }\n    static from(value) {\n        if (value instanceof FixedFormat) {\n            return value;\n        }\n        if (typeof (value) === \"number\") {\n            value = `fixed128x${value}`;\n        }\n        let signed = true;\n        let width = 128;\n        let decimals = 18;\n        if (typeof (value) === \"string\") {\n            if (value === \"fixed\") {\n                // defaults...\n            }\n            else if (value === \"ufixed\") {\n                signed = false;\n            }\n            else {\n                const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n                if (!match) {\n                    logger.throwArgumentError(\"invalid fixed format\", \"format\", value);\n                }\n                signed = (match[1] !== \"u\");\n                width = parseInt(match[2]);\n                decimals = parseInt(match[3]);\n            }\n        }\n        else if (value) {\n            const check = (key, type, defaultValue) => {\n                if (value[key] == null) {\n                    return defaultValue;\n                }\n                if (typeof (value[key]) !== type) {\n                    logger.throwArgumentError(\"invalid fixed format (\" + key + \" not \" + type + \")\", \"format.\" + key, value[key]);\n                }\n                return value[key];\n            };\n            signed = check(\"signed\", \"boolean\", signed);\n            width = check(\"width\", \"number\", width);\n            decimals = check(\"decimals\", \"number\", decimals);\n        }\n        if (width % 8) {\n            logger.throwArgumentError(\"invalid fixed format width (not byte aligned)\", \"format.width\", width);\n        }\n        if (decimals > 80) {\n            logger.throwArgumentError(\"invalid fixed format (decimals too large)\", \"format.decimals\", decimals);\n        }\n        return new FixedFormat(_constructorGuard, signed, width, decimals);\n    }\n}\nexport class FixedNumber {\n    constructor(constructorGuard, hex, value, format) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot use FixedNumber constructor; use FixedNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new FixedFormat\"\n            });\n        }\n        this.format = format;\n        this._hex = hex;\n        this._value = value;\n        this._isFixedNumber = true;\n        Object.freeze(this);\n    }\n    _checkFormat(other) {\n        if (this.format.name !== other.format.name) {\n            logger.throwArgumentError(\"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n        }\n    }\n    addUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);\n    }\n    subUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);\n    }\n    mulUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);\n    }\n    divUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);\n    }\n    floor() {\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) {\n            comps.push(\"0\");\n        }\n        let result = FixedNumber.from(comps[0], this.format);\n        const hasFraction = !comps[1].match(/^(0*)$/);\n        if (this.isNegative() && hasFraction) {\n            result = result.subUnsafe(ONE.toFormat(result.format));\n        }\n        return result;\n    }\n    ceiling() {\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) {\n            comps.push(\"0\");\n        }\n        let result = FixedNumber.from(comps[0], this.format);\n        const hasFraction = !comps[1].match(/^(0*)$/);\n        if (!this.isNegative() && hasFraction) {\n            result = result.addUnsafe(ONE.toFormat(result.format));\n        }\n        return result;\n    }\n    // @TODO: Support other rounding algorithms\n    round(decimals) {\n        if (decimals == null) {\n            decimals = 0;\n        }\n        // If we are already in range, we're done\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) {\n            comps.push(\"0\");\n        }\n        if (decimals < 0 || decimals > 80 || (decimals % 1)) {\n            logger.throwArgumentError(\"invalid decimal count\", \"decimals\", decimals);\n        }\n        if (comps[1].length <= decimals) {\n            return this;\n        }\n        const factor = FixedNumber.from(\"1\" + zeros.substring(0, decimals), this.format);\n        const bump = BUMP.toFormat(this.format);\n        return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);\n    }\n    isZero() {\n        return (this._value === \"0.0\" || this._value === \"0\");\n    }\n    isNegative() {\n        return (this._value[0] === \"-\");\n    }\n    toString() { return this._value; }\n    toHexString(width) {\n        if (width == null) {\n            return this._hex;\n        }\n        if (width % 8) {\n            logger.throwArgumentError(\"invalid byte width\", \"width\", width);\n        }\n        const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();\n        return hexZeroPad(hex, width / 8);\n    }\n    toUnsafeFloat() { return parseFloat(this.toString()); }\n    toFormat(format) {\n        return FixedNumber.fromString(this._value, format);\n    }\n    static fromValue(value, decimals, format) {\n        // If decimals looks more like a format, and there is no format, shift the parameters\n        if (format == null && decimals != null && !isBigNumberish(decimals)) {\n            format = decimals;\n            decimals = null;\n        }\n        if (decimals == null) {\n            decimals = 0;\n        }\n        if (format == null) {\n            format = \"fixed\";\n        }\n        return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));\n    }\n    static fromString(value, format) {\n        if (format == null) {\n            format = \"fixed\";\n        }\n        const fixedFormat = FixedFormat.from(format);\n        const numeric = parseFixed(value, fixedFormat.decimals);\n        if (!fixedFormat.signed && numeric.lt(Zero)) {\n            throwFault(\"unsigned value cannot be negative\", \"overflow\", \"value\", value);\n        }\n        let hex = null;\n        if (fixedFormat.signed) {\n            hex = numeric.toTwos(fixedFormat.width).toHexString();\n        }\n        else {\n            hex = numeric.toHexString();\n            hex = hexZeroPad(hex, fixedFormat.width / 8);\n        }\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n    static fromBytes(value, format) {\n        if (format == null) {\n            format = \"fixed\";\n        }\n        const fixedFormat = FixedFormat.from(format);\n        if (arrayify(value).length > fixedFormat.width / 8) {\n            throw new Error(\"overflow\");\n        }\n        let numeric = BigNumber.from(value);\n        if (fixedFormat.signed) {\n            numeric = numeric.fromTwos(fixedFormat.width);\n        }\n        const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n    static from(value, format) {\n        if (typeof (value) === \"string\") {\n            return FixedNumber.fromString(value, format);\n        }\n        if (isBytes(value)) {\n            return FixedNumber.fromBytes(value, format);\n        }\n        try {\n            return FixedNumber.fromValue(value, 0, format);\n        }\n        catch (error) {\n            // Allow NUMERIC_FAULT to bubble up\n            if (error.code !== Logger.errors.INVALID_ARGUMENT) {\n                throw error;\n            }\n        }\n        return logger.throwArgumentError(\"invalid FixedNumber value\", \"value\", value);\n    }\n    static isFixedNumber(value) {\n        return !!(value && value._isFixedNumber);\n    }\n}\nconst ONE = FixedNumber.from(1);\nconst BUMP = FixedNumber.from(\"0.5\");\n//# sourceMappingURL=fixednumber.js.map","export const version = \"units/5.7.0\";\n//# sourceMappingURL=_version.js.map","\"use strict\";\nimport { formatFixed, parseFixed } from \"@ethersproject/bignumber\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nconst names = [\n    \"wei\",\n    \"kwei\",\n    \"mwei\",\n    \"gwei\",\n    \"szabo\",\n    \"finney\",\n    \"ether\",\n];\n// Some environments have issues with RegEx that contain back-tracking, so we cannot\n// use them.\nexport function commify(value) {\n    const comps = String(value).split(\".\");\n    if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || (comps[1] && !comps[1].match(/^[0-9]*$/)) || value === \".\" || value === \"-.\") {\n        logger.throwArgumentError(\"invalid value\", \"value\", value);\n    }\n    // Make sure we have at least one whole digit (0 if none)\n    let whole = comps[0];\n    let negative = \"\";\n    if (whole.substring(0, 1) === \"-\") {\n        negative = \"-\";\n        whole = whole.substring(1);\n    }\n    // Make sure we have at least 1 whole digit with no leading zeros\n    while (whole.substring(0, 1) === \"0\") {\n        whole = whole.substring(1);\n    }\n    if (whole === \"\") {\n        whole = \"0\";\n    }\n    let suffix = \"\";\n    if (comps.length === 2) {\n        suffix = \".\" + (comps[1] || \"0\");\n    }\n    while (suffix.length > 2 && suffix[suffix.length - 1] === \"0\") {\n        suffix = suffix.substring(0, suffix.length - 1);\n    }\n    const formatted = [];\n    while (whole.length) {\n        if (whole.length <= 3) {\n            formatted.unshift(whole);\n            break;\n        }\n        else {\n            const index = whole.length - 3;\n            formatted.unshift(whole.substring(index));\n            whole = whole.substring(0, index);\n        }\n    }\n    return negative + formatted.join(\",\") + suffix;\n}\nexport function formatUnits(value, unitName) {\n    if (typeof (unitName) === \"string\") {\n        const index = names.indexOf(unitName);\n        if (index !== -1) {\n            unitName = 3 * index;\n        }\n    }\n    return formatFixed(value, (unitName != null) ? unitName : 18);\n}\nexport function parseUnits(value, unitName) {\n    if (typeof (value) !== \"string\") {\n        logger.throwArgumentError(\"value must be a string\", \"value\", value);\n    }\n    if (typeof (unitName) === \"string\") {\n        const index = names.indexOf(unitName);\n        if (index !== -1) {\n            unitName = 3 * index;\n        }\n    }\n    return parseFixed(value, (unitName != null) ? unitName : 18);\n}\nexport function formatEther(wei) {\n    return formatUnits(wei, 18);\n}\nexport function parseEther(ether) {\n    return parseUnits(ether, 18);\n}\n//# sourceMappingURL=index.js.map"],"names":["logger","Logger","version","_constructorGuard","Zero","BigNumber","NegativeOne","throwFault","message","fault","operation","value","params","zeros","getMultiplier","decimals","formatFixed","multiplier","negative","fraction","whole","parseFixed","comps","wholeValue","fractionValue","wei","FixedFormat","constructorGuard","signed","width","match","check","key","type","defaultValue","FixedNumber","hex","format","other","a","b","result","hasFraction","ONE","factor","bump","BUMP","hexZeroPad","isBigNumberish","fixedFormat","numeric","decimal","arrayify","isBytes","error","names","formatUnits","unitName","index","formatEther"],"mappings":"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"}